<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Calligraphy</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #canvas-container {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80vw;
        height: 70vh;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <div id="canvas-container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.skypack.dev/three@0.132.2/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import {
        letterDefinitions,
        createTextGeometry,
      } from "/frontend/utils/format.typography.js";

      // --- CONFIG ---
      const FONT_COLOR_RGBA = "rgba(0, 0, 0, 1.0)";
      const CHAR_SIZE = 7;
      const STROKE_WIDTH = 1;
      const COLS = 5;
      const CAMERA_Z = 50;
      // --------------

      const container = document.getElementById("canvas-container");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.z = CAMERA_Z;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // const controls = new OrbitControls(camera, renderer.domElement);

      const vFOV = THREE.MathUtils.degToRad(camera.fov);
      const viewHeightAtZero = 2 * Math.tan(vFOV / 2) * camera.position.z;
      const viewWidthAtZero = viewHeightAtZero * camera.aspect;

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(20, 80, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      const shadowCamSize = 100;
      directionalLight.shadow.camera.left = -shadowCamSize;
      directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize;
      directionalLight.shadow.camera.bottom = -shadowCamSize;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 200;
      scene.add(directionalLight);

      function createLetterBody(char, x, y, size, options) {
        const stroke = size / 10;
        const w = size;
        const h = size;

        let body;
        const visualOffset = new THREE.Vector3();

        switch (char) {
          case "H": {
            const parts = [
              Matter.Bodies.rectangle(-w / 2 + stroke / 2, 0, stroke, h),
              Matter.Bodies.rectangle(w / 2 - stroke / 2, 0, stroke, h),
              Matter.Bodies.rectangle(0, 0, w, stroke),
            ];
            body = Matter.Body.create({ parts, ...options });
            break;
          }
          case "T": {
            const parts = [
              Matter.Bodies.rectangle(0, -h / 2 + stroke / 2, w, stroke),
              Matter.Bodies.rectangle(0, 0, stroke, h),
            ];
            body = Matter.Body.create({ parts, ...options });
            // CoM is at (0, -0.625). Visual offset must be opposite.
            visualOffset.y = 0.625;
            break;
          }
          case "L": {
            const parts = [
              Matter.Bodies.rectangle(-w / 4, 0, stroke, h),
              Matter.Bodies.rectangle(0, h / 2 - stroke / 2, w / 2, stroke),
            ];
            body = Matter.Body.create({ parts, ...options });
            // CoM is at (-1.125, 1.125). Visual offset must be opposite.
            visualOffset.x = 1.125;
            visualOffset.y = -1.125;
            break;
          }
          case "U": {
            const parts = [
              Matter.Bodies.rectangle(
                -w / 2 + stroke / 2,
                -h / 4,
                stroke,
                h / 2
              ),
              Matter.Bodies.rectangle(
                w / 2 - stroke / 2,
                -h / 4,
                stroke,
                h / 2
              ),
              Matter.Bodies.rectangle(0, h / 2 - stroke / 2, w, stroke),
            ];
            body = Matter.Body.create({ parts, ...options });
            // CoM is at (0, 0.625). Visual offset must be opposite.
            visualOffset.y = -0.625;
            break;
          }
          default: {
            body = Matter.Bodies.rectangle(0, 0, w, h, options);
            break;
          }
        }
        Matter.Body.setPosition(body, { x, y });
        return { body, visualOffset };
      }

      // --- Matter.js setup ---
      const engine = Matter.Engine.create();
      const world = engine.world;
      world.gravity.y = -0.2;

      const wallOptions = { isStatic: true, restitution: 0.8 };
      const wallThickness = 1;
      const wallHeight = viewHeightAtZero * 1.5;

      Matter.World.add(world, [
        Matter.Bodies.rectangle(
          -viewWidthAtZero / 2 - wallThickness / 2,
          0,
          wallThickness,
          wallHeight,
          wallOptions
        ),
        Matter.Bodies.rectangle(
          viewWidthAtZero / 2 + wallThickness / 2,
          0,
          wallThickness,
          wallHeight,
          wallOptions
        ),
      ]);

      const allChars = Object.keys(letterDefinitions).sort((a, b) => {
        const getSortGroup = (char) => {
          if (/[a-zA-Z]/.test(char)) return 0; // Letters
          if (/[0-9]/.test(char)) return 1; // Numbers
          return 2; // Other symbols
        };
        const groupA = getSortGroup(a);
        const groupB = getSortGroup(b);
        if (groupA !== groupB) {
          return groupB - groupA;
        }
        return b.localeCompare(a);
      });

      const objects = [];
      const tempGridGroup = new THREE.Group();
      const spacing = CHAR_SIZE * 1.05;

      for (let i = 0; i < allChars.length; i++) {
        const char = allChars[i];
        const row = Math.floor(i / COLS);
        const col = i % COLS;

        const color = new THREE.Color(
          new THREE.Color(FONT_COLOR_RGBA).getHex()
        );
        const opacity = parseFloat(FONT_COLOR_RGBA.split(",")[3]);
        const textGeo = createTextGeometry(char, {
          size: CHAR_SIZE,
          color,
          strokeWidth: STROKE_WIDTH,
          opacity,
        });
        textGeo.rotation.x = Math.PI;

        const wrapper = new THREE.Group();
        wrapper.add(textGeo);
        wrapper.userData.char = char;

        wrapper.position.x = (COLS - 1 - col) * spacing;
        wrapper.position.y = row * spacing;
        tempGridGroup.add(wrapper);
      }

      const gridBox = new THREE.Box3().setFromObject(tempGridGroup);
      const gridCenter = new THREE.Vector3();
      gridBox.getCenter(gridCenter);
      tempGridGroup.position.sub(gridCenter);
      tempGridGroup.position.y += 20;
      tempGridGroup.updateWorldMatrix(true, false);

      const worldPos = new THREE.Vector3();
      [...tempGridGroup.children].forEach((wrapper) => {
        wrapper.getWorldPosition(worldPos);

        wrapper.traverse(function (node) {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });

        scene.add(wrapper);

        const char = wrapper.userData.char;
        const { body, visualOffset } = createLetterBody(
          char,
          worldPos.x,
          worldPos.y,
          CHAR_SIZE,
          {
            restitution: 0.8,
            angularVelocity: (Math.random() - 0.5) * 0.1,
            friction: 0.1,
            frictionAir: 0.01,
          }
        );

        // Apply the visual offset to the mesh inside the wrapper
        wrapper.children[0].position.copy(visualOffset);

        Matter.World.add(world, body);
        objects.push({ mesh: wrapper, body: body });
      });

      // --- Ground ---
      const groundBody = Matter.Bodies.rectangle(0, -45, viewWidthAtZero, 20, {
        isStatic: true,
        restitution: 0.8,
      });
      Matter.World.add(world, groundBody);

      const groundGeometry = new THREE.PlaneGeometry(300, 300);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0xf0f0f0,
        roughness: 0.9,
        metalness: 0.1,
      });
      const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.position.y = -35;
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);

      function animate() {
        requestAnimationFrame(animate);
        // controls.update();

        // Update Matter.js engine
        Matter.Engine.update(engine);

        // Synchronize Three.js meshes with Matter.js bodies
        objects.forEach((obj) => {
          obj.mesh.position.set(obj.body.position.x, obj.body.position.y, 0);
          obj.mesh.quaternion.setFromAxisAngle(
            new THREE.Vector3(0, 0, 1),
            obj.body.angle
          );
        });

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        const width = container.clientWidth;
        const height = container.clientHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
      });
    </script>
  </body>
</html>
