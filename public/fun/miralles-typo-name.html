<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Calligraphy</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #canvas-container {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80vw;
        height: 70vh;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <div id="canvas-container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.skypack.dev/three@0.132.2/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import {
        letterDefinitions,
        createTextGeometry,
      } from "/frontend/utils/format.typography.js";

      // --- CONFIG ---
      const FONT_COLOR_RGBA = "rgba(0, 0, 0, 0.6)";
      const CHAR_SIZE = 7;
      const STROKE_WIDTH = 1;
      const COLS = 5;
      const CAMERA_Z = 50;
      const TARGET_WORD = "ORIGEN"; // Letters to suspend
      const START_DELAY_MS = 0; // Time to present the grid before animation starts
      const GRAVITY_Y = -0.4; // Downward gravity in this coordinate system
      const RAMP_DURATION_MS = 900; // Ease-in for rope stiffness
      const ANCHOR_MOVE_MS = 900; // Duration for moving anchors from grid 'A'/'L' to final positions
      const ALIGN_RAMP_MS = 6000; // Duration to straighten the word and orient letters
      const ALIGN_TARGET_STIFFNESS = 0.5; // How straight the final line should be
      const SPACE_GAP_WEIGHT = 0.9; // Extra spacing unit added for each space between letters
      const LAUNCH_IMPULSE_Y = 2.5; // Initial upward velocity to make the grid rise
      const LAUNCH_DURATION_MS = 800; // Time to rise before the word is caught
      // Independent opacity animation for word letters
      const WORD_ALPHA_RAMP_MS = 3500; // duration to reach final alpha
      const WORD_ALPHA_START_OFFSET_MS = 0; // delay relative to alignment start
      const WORD_ALPHA_TARGET_ALPHA = 0.9; // final opacity for word letters
      // --------------

      const container = document.getElementById("canvas-container");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.z = CAMERA_Z;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // const controls = new OrbitControls(camera, renderer.domElement);

      const vFOV = THREE.MathUtils.degToRad(camera.fov);
      const viewHeightAtZero = 2 * Math.tan(vFOV / 2) * camera.position.z;
      const viewWidthAtZero = viewHeightAtZero * camera.aspect;

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(20, 80, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      const shadowCamSize = 100;
      directionalLight.shadow.camera.left = -shadowCamSize;
      directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize;
      directionalLight.shadow.camera.bottom = -shadowCamSize;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 200;
      scene.add(directionalLight);

      function createLetterBody(char, x, y, size, options) {
        const stroke = size / 10;
        const w = size;
        const h = size;

        let body;
        const visualOffset = new THREE.Vector3();

        switch (char) {
          case "H": {
            const parts = [
              Matter.Bodies.rectangle(-w / 2 + stroke / 2, 0, stroke, h),
              Matter.Bodies.rectangle(w / 2 - stroke / 2, 0, stroke, h),
              Matter.Bodies.rectangle(0, 0, w, stroke),
            ];
            body = Matter.Body.create({ parts, ...options });
            break;
          }
          case "T": {
            const parts = [
              Matter.Bodies.rectangle(0, -h / 2 + stroke / 2, w, stroke),
              Matter.Bodies.rectangle(0, 0, stroke, h),
            ];
            body = Matter.Body.create({ parts, ...options });
            // CoM is at (0, -0.625). Visual offset must be opposite.
            visualOffset.y = 0.625;
            break;
          }
          case "L": {
            const parts = [
              Matter.Bodies.rectangle(-w / 4, 0, stroke, h),
              Matter.Bodies.rectangle(0, h / 2 - stroke / 2, w / 2, stroke),
            ];
            body = Matter.Body.create({ parts, ...options });
            // CoM is at (-1.125, 1.125). Visual offset must be opposite.
            visualOffset.x = 1.125;
            visualOffset.y = -1.125;
            break;
          }
          case "U": {
            const parts = [
              Matter.Bodies.rectangle(
                -w / 2 + stroke / 2,
                -h / 4,
                stroke,
                h / 2
              ),
              Matter.Bodies.rectangle(
                w / 2 - stroke / 2,
                -h / 4,
                stroke,
                h / 2
              ),
              Matter.Bodies.rectangle(0, h / 2 - stroke / 2, w, stroke),
            ];
            body = Matter.Body.create({ parts, ...options });
            // CoM is at (0, 0.625). Visual offset must be opposite.
            visualOffset.y = -0.625;
            break;
          }
          default: {
            body = Matter.Bodies.rectangle(0, 0, w, h, options);
            break;
          }
        }
        Matter.Body.setPosition(body, { x, y });
        return { body, visualOffset };
      }

      // --- Matter.js setup ---
      const engine = Matter.Engine.create();
      const world = engine.world;
      // Show the grid first without motion
      world.gravity.y = 0;

      const wallOptions = { isStatic: true, restitution: 0.8 };
      const wallThickness = 1;
      const wallHeight = viewHeightAtZero * 1.5;

      Matter.World.add(world, [
        Matter.Bodies.rectangle(
          -viewWidthAtZero / 2 - wallThickness / 2,
          0,
          wallThickness,
          wallHeight,
          wallOptions
        ),
        Matter.Bodies.rectangle(
          viewWidthAtZero / 2 + wallThickness / 2,
          0,
          wallThickness,
          wallHeight,
          wallOptions
        ),
      ]);

      const allChars = Object.keys(letterDefinitions).sort((a, b) => {
        const getSortGroup = (char) => {
          if (/[a-zA-Z]/.test(char)) return 0; // Letters
          if (/[0-9]/.test(char)) return 1; // Numbers
          return 2; // Other symbols
        };
        const groupA = getSortGroup(a);
        const groupB = getSortGroup(b);
        if (groupA !== groupB) {
          return groupB - groupA;
        }
        return b.localeCompare(a);
      });

      const objects = [];
      const updaters = [];
      const tempGridGroup = new THREE.Group();
      const spacing = CHAR_SIZE * 1.05;

      for (let i = 0; i < allChars.length; i++) {
        const char = allChars[i];
        const row = Math.floor(i / COLS);
        const col = i % COLS;

        const color = new THREE.Color(
          new THREE.Color(FONT_COLOR_RGBA).getHex()
        );
        const opacity = parseFloat(FONT_COLOR_RGBA.split(",")[3]);
        const textGeo = createTextGeometry(char, {
          size: CHAR_SIZE,
          color,
          strokeWidth: STROKE_WIDTH,
          opacity,
        });
        textGeo.rotation.x = Math.PI;

        const wrapper = new THREE.Group();
        wrapper.add(textGeo);
        wrapper.userData.char = char;

        wrapper.position.x = (COLS - 1 - col) * spacing;
        wrapper.position.y = row * spacing;
        tempGridGroup.add(wrapper);
      }

      const gridBox = new THREE.Box3().setFromObject(tempGridGroup);
      const gridCenter = new THREE.Vector3();
      gridBox.getCenter(gridCenter);
      tempGridGroup.position.sub(gridCenter);
      // Start centered vertically; we will give an upward impulse at start instead
      // to emulate a bounce up before the fall
      // tempGridGroup.position.y += 20;
      tempGridGroup.updateWorldMatrix(true, false);

      const worldPos = new THREE.Vector3();
      [...tempGridGroup.children].forEach((wrapper) => {
        wrapper.getWorldPosition(worldPos);

        wrapper.traverse(function (node) {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });

        scene.add(wrapper);

        const char = wrapper.userData.char;
        const { body, visualOffset } = createLetterBody(
          char,
          worldPos.x,
          worldPos.y,
          CHAR_SIZE,
          {
            restitution: 0.8,
            angularVelocity: (Math.random() - 0.5) * 0.1,
            friction: 0.1,
            frictionAir: 0.01,
          }
        );

        // Apply the visual offset to the mesh inside the wrapper
        wrapper.children[0].position.copy(visualOffset);

        Matter.World.add(world, body);
        objects.push({ mesh: wrapper, body: body });
      });

      // --- Suspend TARGET_WORD across the top with spring-like constraints ---
      function createClotheslineForWord() {
        const word = TARGET_WORD.toUpperCase();
        if (!word || word.length === 0) return;

        // Build a map from character to available objects (bodies)
        const charToBodies = new Map();
        for (const obj of objects) {
          const c = (obj.mesh?.userData?.char || "").toUpperCase();
          if (!c) continue;
          if (!charToBodies.has(c)) charToBodies.set(c, []);
          charToBodies.get(c).push(obj);
        }

        // Anchor positions near the top-left and top-right of the visible area
        const margin = CHAR_SIZE * 1.8;
        const anchorY = viewHeightAtZero / 2 - margin;
        const anchorLeftX = -viewWidthAtZero / 2 + margin;
        const anchorRightX = viewWidthAtZero / 2 - margin;

        // Choose or create one body per letter in order, supporting repeated letters and spaces
        const chosenBodies = [];
        const lettersSpaceBefore = [];
        const charUseIndex = new Map();
        let lastWasSpace = false;
        for (let i = 0; i < word.length; i++) {
          const ch = word[i];
          if (ch === " ") {
            lastWasSpace = true;
            continue;
          }
          const list = charToBodies.get(ch) || [];
          const useIdx = charUseIndex.get(ch) || 0;
          let picked = list[useIdx];

          if (!picked) {
            // Need to create a duplicate mesh + body for this repeated letter
            const color = new THREE.Color(new THREE.Color(FONT_COLOR_RGBA).getHex());
            const opacity = parseFloat(FONT_COLOR_RGBA.split(",")[3]);
            const textGeo = createTextGeometry(ch, {
              size: CHAR_SIZE,
              color,
              strokeWidth: STROKE_WIDTH,
              opacity,
            });
            textGeo.rotation.x = Math.PI;

            const wrapper = new THREE.Group();
            wrapper.add(textGeo);
            wrapper.userData.char = ch;
            scene.add(wrapper);

            // Place at the same position as the first instance of this char so it blends into the grid
            const sourcePos = list[0]?.body?.position || { x: anchorLeftX, y: anchorY };
            const { body, visualOffset } = createLetterBody(
              ch,
              sourcePos.x,
              sourcePos.y,
              CHAR_SIZE,
              {
                restitution: 0.8,
                angularVelocity: 0,
                friction: 0.1,
                frictionAir: 0.01,
              }
            );

            // Apply the visual offset to center the glyph inside wrapper
            wrapper.children[0].position.copy(visualOffset);

            Matter.World.add(world, body);
            picked = { mesh: wrapper, body };
            objects.push(picked);
          }

          // Record usage of this character index
          charUseIndex.set(ch, useIdx + 1);
          chosenBodies.push(picked);
          lettersSpaceBefore.push(lastWasSpace);
          lastWasSpace = false;
        }

        const lettersCount = chosenBodies.length;
        if (lettersCount < 2) return; // Need at least two to span

        // Collect materials for the word letters to animate opacity
        const wordLetterMaterials = [];
        for (let i = 0; i < chosenBodies.length; i++) {
          let materialRef = null;
          chosenBodies[i].mesh.traverse((node) => {
            if (!materialRef && node.isMesh && node.material) {
              materialRef = node.material;
            }
          });
          if (materialRef) {
            materialRef.transparent = true;
            wordLetterMaterials.push(materialRef);
          }
        }
        const baseWordAlpha =
          (wordLetterMaterials[0]?.opacity ??
            parseFloat(FONT_COLOR_RGBA.split(",")[3]) ??
            0.6);

        // Configure collision filtering so non-target letters pass through the word
        const CAT_OTHER = 0x0001; // default category
        const CAT_WORD = 0x0002;  // category for TARGET_WORD letters
        const chosenSet = new Set(chosenBodies.map((o) => o.body.id));
        for (const obj of objects) {
          const isWordLetter = chosenSet.has(obj.body.id);
          obj.body.collisionFilter = obj.body.collisionFilter || {};
          obj.body.collisionFilter.category = isWordLetter ? CAT_WORD : CAT_OTHER;
          obj.body.collisionFilter.mask = isWordLetter
            ? 0xffff // word letters collide normally (constraints manage layout)
            : 0xffff & ~CAT_WORD; // others ignore collisions with the word
        }

        // Create spring-like constraints between letters and anchors
        const constraints = [];

        // Determine initial anchors from current locations of first and last letters in the grid
        const startLeft = {
          x: chosenBodies[0].body.position.x,
          y: chosenBodies[0].body.position.y,
        };
        const startRight = {
          x: chosenBodies[chosenBodies.length - 1].body.position.x,
          y: chosenBodies[chosenBodies.length - 1].body.position.y,
        };

        // Anchor first letter to top-left point (start at its grid position)
        constraints.push(
          Matter.Constraint.create({
            pointA: { x: startLeft.x, y: startLeft.y },
            bodyB: chosenBodies[0].body,
            pointB: { x: 0, y: 0 },
            length: 0,
            stiffness: 0.005, // will ramp to target
            damping: 0.2,
          })
        );

        // Anchor last letter to top-right point (start at its grid position)
        constraints.push(
          Matter.Constraint.create({
            pointA: { x: startRight.x, y: startRight.y },
            bodyB: chosenBodies[chosenBodies.length - 1].body,
            pointB: { x: 0, y: 0 },
            length: 0,
            stiffness: 0.005, // will ramp to target
            damping: 0.2,
          })
        );

        // Link letters together to form the "clothesline"
        // Link length based on current spacing in the grid to avoid a pop
        for (let i = 1; i < chosenBodies.length; i++) {
          const prevPos = chosenBodies[i - 1].body.position;
          const curPos = chosenBodies[i].body.position;
          let linkLength = Math.hypot(curPos.x - prevPos.x, curPos.y - prevPos.y) * 0.95;
          // Loosen the link if there is a space before this letter to remove jitter
          if (lettersSpaceBefore[i]) {
            linkLength += CHAR_SIZE * SPACE_GAP_WEIGHT;
          }
          constraints.push(
            Matter.Constraint.create({
              bodyA: chosenBodies[i - 1].body,
              pointA: { x: 0, y: 0 },
              bodyB: chosenBodies[i].body,
              pointB: { x: 0, y: 0 },
              length: linkLength,
              stiffness: lettersSpaceBefore[i] ? 0.0025 : 0.005, // softer near spaces
              damping: lettersSpaceBefore[i] ? 0.28 : 0.18, // higher damping near spaces
            })
          );
        }

        Matter.World.add(world, constraints);

        // Ease-in rope stiffness so the word "unwraps" from the grid instead of popping
        const anchorTarget = 0.06; // softer rope
        const linkTarget = 0.045; // softer rope
        const start = performance.now();
        function ramp() {
          const t = Math.min(1, (performance.now() - start) / RAMP_DURATION_MS);
          const eased = t * t * (3 - 2 * t); // smoothstep
          for (let i = 0; i < constraints.length; i++) {
            const isAnchor = constraints[i].pointA && !constraints[i].bodyA;
            const target = isAnchor ? anchorTarget : linkTarget;
            constraints[i].stiffness = 0.005 + (target - 0.005) * eased;
          }
          if (t < 1) requestAnimationFrame(ramp);
        }
        requestAnimationFrame(ramp);

        // Animate anchor points from A/L grid positions to final top-left/right positions
        const moveStart = performance.now();
        const leftConstraint = constraints[0];
        const rightConstraint = constraints[1];
        updaters.push(() => {
          const t = Math.min(1, (performance.now() - moveStart) / ANCHOR_MOVE_MS);
          const eased = t * t * (3 - 2 * t); // smoothstep
          leftConstraint.pointA.x = startLeft.x + (anchorLeftX - startLeft.x) * eased;
          leftConstraint.pointA.y = startLeft.y + (anchorY - startLeft.y) * eased;
          rightConstraint.pointA.x = startRight.x + (anchorRightX - startRight.x) * eased;
          rightConstraint.pointA.y = startRight.y + (anchorY - startRight.y) * eased;
        });

        // Add gentle align-to-line constraints for each letter and ramp their stiffness near the end
        // Final target positions with extra spacing for spaces to avoid letter crowding and vibration
        const totalExtra = lettersSpaceBefore.reduce((s, v) => s + (v ? 1 : 0), 0);
        const baseCount = lettersCount - 1 + totalExtra * SPACE_GAP_WEIGHT;
        const finalTargets = [];
        let acc = 0;
        for (let i = 0; i < lettersCount; i++) {
          if (i > 0) acc += 1 + (lettersSpaceBefore[i] ? SPACE_GAP_WEIGHT : 0);
          const t = baseCount === 0 ? 0 : acc / baseCount;
          finalTargets.push({ x: anchorLeftX + t * (anchorRightX - anchorLeftX), y: anchorY });
        }
        const alignConstraints = [];
        for (let i = 0; i < chosenBodies.length; i++) {
          alignConstraints.push(
            Matter.Constraint.create({
              pointA: { ...finalTargets[i] },
              bodyB: chosenBodies[i].body,
              pointB: { x: 0, y: 0 },
              length: 0,
              stiffness: 0.001, // start almost free
              damping: 0.25,
            })
          );
        }
        Matter.World.add(world, alignConstraints);

        const alignStart = moveStart + ANCHOR_MOVE_MS * 0.5; // start alignment halfway through anchor move
        updaters.push(() => {
          const now = performance.now();
          const tt = Math.min(1, Math.max(0, (now - alignStart) / ALIGN_RAMP_MS));
          const smooth = tt * tt * (3 - 2 * tt);
          for (let i = 0; i < alignConstraints.length; i++) {
            const extra = lettersSpaceBefore[i] ? 0.15 : 0;
            alignConstraints[i].stiffness = 0.001 + (ALIGN_TARGET_STIFFNESS + extra - 0.001) * smooth;
          }
          // Smoothly orient letters upright (angle -> 0)
          for (let i = 0; i < chosenBodies.length; i++) {
            const b = chosenBodies[i].body;
            // reduce spin
            Matter.Body.setAngularVelocity(b, b.angularVelocity * (1 - 0.7 * smooth));
            // gently nudge angle towards 0
            Matter.Body.setAngle(b, b.angle * (1 - 0.15 * smooth));
          }
          // Ramp opacity of word letters using independent timing
          const ta = Math.min(
            1,
            Math.max(
              0,
              (now - (alignStart + WORD_ALPHA_START_OFFSET_MS)) / WORD_ALPHA_RAMP_MS
            )
          );
          const smoothAlpha = ta * ta * (3 - 2 * ta);
          for (let i = 0; i < wordLetterMaterials.length; i++) {
            const mat = wordLetterMaterials[i];
            mat.opacity =
              baseWordAlpha +
              (WORD_ALPHA_TARGET_ALPHA - baseWordAlpha) * smoothAlpha;
            mat.needsUpdate = true;
          }
        });
      }

      // --- Ground ---
      const groundBody = Matter.Bodies.rectangle(0, -45, viewWidthAtZero, 20, {
        isStatic: true,
        restitution: 0.8,
      });
      Matter.World.add(world, groundBody);
      // Start the animation after a brief delay to present the grid first
      setTimeout(() => {
        // Apply an initial upward impulse so the grid rises before falling
        objects.forEach((obj) => {
          Matter.Body.setVelocity(obj.body, { x: 0, y: LAUNCH_IMPULSE_Y });
          Matter.Body.setAngularVelocity(obj.body, 0);
        });
        world.gravity.y = GRAVITY_Y;
        // After the rise, catch the target word so it unwraps naturally
        setTimeout(() => {
          createClotheslineForWord();
        }, LAUNCH_DURATION_MS);
      }, START_DELAY_MS);

      const groundGeometry = new THREE.PlaneGeometry(300, 300);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0xf0f0f0,
        roughness: 0.9,
        metalness: 0.1,
      });
      const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.position.y = -35;
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);

      function animate() {
        requestAnimationFrame(animate);
        // controls.update();

        // Update Matter.js engine
        Matter.Engine.update(engine);

        // Synchronize Three.js meshes with Matter.js bodies
        objects.forEach((obj) => {
          obj.mesh.position.set(obj.body.position.x, obj.body.position.y, 0);
          obj.mesh.quaternion.setFromAxisAngle(
            new THREE.Vector3(0, 0, 1),
            obj.body.angle
          );
        });

        // Per-frame procedural updates (e.g., moving anchors)
        for (let i = 0; i < updaters.length; i++) {
          updaters[i]();
        }

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        const width = container.clientWidth;
        const height = container.clientHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
      });
    </script>
  </body>
</html>
